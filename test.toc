
;; TODO: make sure eval-free only needs to implement 'map'

(add-ns id (module "core/id.toc"))
(main [_]
      (let [double (fn [x]
                     (* 2 x))]
        ;; check the functor and applicative laws for free
        (println :free)
        (println :functor-1 (= (evaluate (map (free 5) identity) id/id-m)
                               (evaluate (free 5) id/id-m)))
        (println :functor-2 (= (evaluate (map (map (free 2) inc) double) id/id-m)
                               (evaluate (map (free 2) (comp inc double)) id/id-m)))
        (println :apply-1 (= (evaluate (map (free 5) inc) id/id-m)
                             (evaluate (apply-to inc (free 5)) id/id-m)))
        (println :apply-2 (= (evaluate (free 5) id/id-m)
                             (evaluate (apply-to identity (free 5)) id/id-m)))
        (let [v1 (free "first ")
              v2 (free "second ")
              v3 (free "third")]
          (println :apply-3 (= (evaluate (apply-to comp (apply-to comp v1 v2) v3) id/id-m)
                               (evaluate (apply-to comp v1 (apply-to comp v2 v3)) id/id-m)
                               (evaluate (apply-to comp v1 v2 v3) id/id-m))))

        (let [f-inc (fn [x] (free (inc x)))
              f-dbl (fn [x] (free (double x)))]
          (println :flat-map-1 (= (evaluate (flat-map (free 4) f-inc) id/id-m)
                                  (evaluate (f-inc 4) id/id-m)))
          (println :flat-map-2 (= (evaluate (flat-map (free 4) free) id/id-m)
                                  (evaluate (free 4) id/id-m)))
          (println :flat-map-3 (= (evaluate (flat-map (flat-map (free 4) f-inc) f-dbl) id/id-m)
                                  (evaluate (flat-map (free 4) (fn [x] (flat-map (f-inc x) f-dbl))) id/id-m))))))
